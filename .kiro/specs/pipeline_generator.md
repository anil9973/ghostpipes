# Pipeline Generator Usage Guide

## Overview

The `PipelineGenerator` class converts user intent into executable pipelines using AI (Gemini API). It handles:

1. **Prompt Construction** - Builds detailed, explanatory prompts
2. **AI Communication** - Calls Gemini API with retry logic
3. **Response Parsing** - Extracts and validates JSON from AI response
4. **Node Creation** - Converts AI data to `PipeNode` instances
5. **Position Calculation** - Arranges nodes visually in layers
6. **Pipe Generation** - Creates connection objects between nodes

---

## Basic Usage

```javascript
import { PipelineGenerator } from "./core/ai/PipelineGenerator.js";

// Generate pipeline from user intent
const result = await aiService.generatePipeline({
	intent: "Track Amazon laptop prices daily",
	dataSource: "https://amazon.com/laptop/B08XYZ",
	dataType: "html",
	trigger: "schedule",
});

console.log("Generated nodes:", result.nodes);
console.log("Generated pipes:", result.pipes);
console.log("AI reasoning:", result.reasoning);
```

---

## Input Format

### Context Object

```javascript
{
  intent: string,        // REQUIRED: What user wants to accomplish
  dataSource: string,    // OPTIONAL: URL, file path, or data preview
  dataType: string,      // OPTIONAL: html, csv, json, xml, text
  trigger: string        // OPTIONAL: manual, schedule, webhook
}
```

### Examples

**Web Scraping:**

```javascript
{
  intent: 'Extract product prices from Amazon',
  dataSource: 'https://amazon.com/product/B08XYZ',
  dataType: 'html',
  trigger: 'schedule'
}
```

**CSV Processing:**

```javascript
{
  intent: 'Filter customers by age > 30 and save as JSON',
  dataSource: 'customers.csv',
  dataType: 'csv',
  trigger: 'manual'
}
```

**API Integration:**

```javascript
{
  intent: 'Fetch GitHub issues and send daily summary email',
  dataSource: 'https://api.github.com/repos/user/repo/issues',
  dataType: 'json',
  trigger: 'schedule'
}
```

---

## Output Format

### Generated Pipeline Object

```javascript
{
  nodes: [
    {
      id: "fetch_amazon_page",
      type: "http_request",
      title: "Fetch Product Page",
      summary: "GET https://amazon.com/laptop/B08XYZ",
      position: { x: 600, y: 100 },
      config: {
        method: "GET",
        url: "https://amazon.com/laptop/B08XYZ",
        headers: [...]
      },
      inputs: [],
      outputs: [
        {
          nodeId: "parse_product_data",
          outputSchema: {
            raw_data: "string"
          }
        }
      ]
    },
    // More nodes...
  ],

  pipes: [
    {
      id: "pipe_1",
      source: "fetch_amazon_page",
      sourceSide: "bottom",
      target: "parse_product_data",
      targetSide: "top"
    },
    // More pipes...
  ],

  reasoning: "Linear pipeline: Fetch page â†’ Parse data â†’ Check condition â†’ Notify"
}
```

---

## Node Structure Explanation

### PipeNode Properties

```javascript
{
  // Identity
  id: "descriptive_node_id",       // Generated by AI or UUID
  type: "http_request",             // Node type from registry
  title: "Fetch Product Page",     // Human-readable title

  // Visual
  position: { x: 600, y: 100 },    // Calculated automatically

  // Description
  summary: "GET https://...",       // AI-generated or config-based

  // Configuration
  config: {
    // Type-specific configuration
    // Matches the Config classes (HttpFetchConfig, etc.)
  },

  // Connections with schemas
  inputs: [
    {
      nodeId: "previous_node",
      inputSchema: {
        field1: "string",
        field2: "number"
      }
    }
  ],

  outputs: [
    {
      nodeId: "next_node",
      outputSchema: {
        result: "object"
      }
    }
  ]
}
```

### Schema Structure

Schemas describe the data flowing between nodes:

```javascript
// Simple schema
{
  "price": "number",
  "title": "string",
  "inStock": "boolean"
}

// Nested schema
{
  "product": {
    "id": "string",
    "details": {
      "price": "number",
      "specs": "array"
    }
  }
}

// Array schema
{
  "items": "array",
  "count": "number"
}
```

---

## Position Calculation

### How Node Positioning Works

**Algorithm:**

1. Calculate layers using BFS (Breadth-First Search)
2. Layer 0 = nodes with no inputs (input nodes)
3. Each subsequent layer = nodes whose inputs are in previous layers
4. Center nodes horizontally within viewport
5. Space layers vertically by 250px

**Spacing Constants:**

```javascript
VIEWPORT_WIDTH = window.innerWidth - 220; // ~1200px on 1920px screen
LAYER_HEIGHT = 250; // Vertical spacing
MIN_HORIZONTAL_SPACING = 450; // Horizontal spacing
```

**Example Layout:**

```
Layer 0 (y=100):
  [Input Node A]--------[Input Node B]
         |                     |
         |                     |
Layer 1 (y=350):
       [Process Node C]--------[Process Node D]
                 |
                 |
Layer 2 (y=600):
            [Output Node E]
```

---

## Pipe Generation

### Pipe Structure

```javascript
{
  id: "pipe_1",              // Unique identifier
  source: "node_a",          // Source node ID
  sourceSide: "bottom",      // Connection side: top, bottom, left, right
  target: "node_b",          // Target node ID
  targetSide: "top"          // Connection side
}
```

### Connection Side Logic

**Vertical Flow (default):**

- Source below target â†’ `sourceSide: "top"`, `targetSide: "bottom"`
- Target below source â†’ `sourceSide: "bottom"`, `targetSide: "top"`

**Horizontal Flow:**

- Target to the right â†’ `sourceSide: "right"`, `targetSide: "left"`
- Target to the left â†’ `sourceSide: "left"`, `targetSide: "right"`

---

## Validation

### Validate Before Execution

```javascript
const errors = generator.validatePipeline(result.nodes);

if (errors.length > 0) {
	console.error("Pipeline validation failed:", errors);
	// Handle errors
} else {
	console.log("Pipeline is valid!");
	// Proceed with execution
}
```

### Common Validation Errors

1. **No input node**: `"Pipeline must have at least one input node"`
2. **No output node**: `"Pipeline must have at least one output node"`
3. **Invalid connections**: `"Node 'X' references non-existent output 'Y'"`
4. **Circular dependency**: `"Pipeline contains circular dependency"`
5. **Disconnected nodes**: `"Disconnected nodes: node_1, node_2"`
6. **Config errors**: `"Node 'filter_1': At least one rule required"`

---

## Complexity Estimation

### Get Pipeline Metrics

```javascript
const metrics = generator.estimateComplexity(result.nodes);

console.log("Total nodes:", metrics.totalNodes);
console.log("Total layers:", metrics.totalLayers);
console.log("Has conditions:", metrics.hasConditions);
console.log("Has loops:", metrics.hasLoops);
console.log("Has AI:", metrics.hasAI);
console.log("Estimated duration:", metrics.estimatedDuration, "ms");
```

### Output Example

```javascript
{
  totalNodes: 5,
  totalLayers: 3,
  maxNodesPerLayer: 2,
  hasConditions: true,
  hasLoops: false,
  hasAI: false,
  estimatedDuration: 4200  // milliseconds
}
```

---

## Error Handling

### API Errors

```javascript
try {
	const result = await generator.generatePipeline(context);
} catch (error) {
	if (error.message.includes("Gemini API error")) {
		console.error("API communication failed:", error);
		// Show user: "Failed to connect to AI service"
	} else if (error.message.includes("Invalid pipeline JSON")) {
		console.error("AI returned invalid response:", error);
		// Show user: "AI generated invalid pipeline, please try again"
	} else {
		console.error("Unknown error:", error);
		// Show user: "Something went wrong"
	}
}
```

### Validation Errors

```javascript
const errors = generator.validatePipeline(nodes);

if (errors.length > 0) {
	// Display errors to user
	errors.forEach((error) => {
		console.error("Validation error:", error);
	});

	// Offer to fix automatically or edit manually
}
```

---

## Advanced Usage

### Generate Summary for Existing Node

```javascript
// User modified a node's config, regenerate summary
const node = nodes.find((n) => n.id === "filter_1");
const newSummary = await generator.generateNodeSummary(node);
node.summary = newSummary;
```

### Recalculate Positions After Manual Edit

```javascript
// User added/removed nodes manually
generator.calculateNodePositions(nodes);
const pipes = generator.generatePipes(nodes);
```

### Custom Positioning

```javascript
// Override auto-positioning for specific nodes
const nodes = result.nodes;

// Keep auto-positions for most nodes
generator.calculateNodePositions(nodes);

// Override specific node
const specialNode = nodes.find((n) => n.id === "special_node");
specialNode.position = { x: 800, y: 150 };

// Regenerate pipes to match new positions
const pipes = generator.generatePipes(nodes);
```

---

## Integration Example

### Complete Flow in UI Component

```javascript
import { PipelineGenerator } from "./core/ai/PipelineGenerator.js";

class PipelineBuilder extends HTMLElement {
	state = react({
		nodes: [],
		pipes: [],
		isGenerating: false,
		error: null,
	});

	async handleGeneratePipeline(userIntent) {
		this.state.isGenerating = true;
		this.state.error = null;

		try {
			const generator = new PipelineGenerator({
				apiKey: this.getApiKey(),
			});

			const result = await generator.generatePipeline({
				intent: userIntent,
				trigger: "manual",
			});

			// Validate
			const errors = generator.validatePipeline(result.nodes);
			if (errors.length > 0) {
				throw new Error(`Validation failed: ${errors.join(", ")}`);
			}

			// Update state
			this.state.nodes = result.nodes;
			this.state.pipes = result.pipes;

			// Show success
			this.showToast("Pipeline generated successfully!");
		} catch (error) {
			this.state.error = error.message;
			this.showToast("Failed to generate pipeline", "error");
		} finally {
			this.state.isGenerating = false;
		}
	}

	render() {
		return html`
			<div class="pipeline-builder">
				${() =>
					this.state.isGenerating ? html` <div class="loading">Summoning pipeline from the void...</div> ` : ""} ${() =>
					this.state.error ? html` <div class="error">ðŸ’€ ${this.state.error}</div> ` : ""}

				<canvas-component .nodes=${() => this.state.nodes} .pipes=${() => this.state.pipes}></canvas-component>
			</div>
		`;
	}
}
```

---

## Testing

### Mock AI Response for Testing

```javascript
class MockPipelineGenerator extends PipelineGenerator {
	async callGeminiAPI(prompt) {
		// Return mock response instead of calling API
		return JSON.stringify({
			nodes: [
				{
					id: "test_input",
					type: "manual_input",
					title: "Test Input",
					summary: "Manual input (1 types)",
					config: {},
					inputs: [],
					outputs: [
						{
							nodeId: "test_output",
							outputSchema: { data: "string" },
						},
					],
				},
				{
					id: "test_output",
					type: "download",
					title: "Test Output",
					summary: "Download data.json",
					config: { filename: "data.json" },
					inputs: [
						{
							nodeId: "test_input",
							inputSchema: { data: "string" },
						},
					],
					outputs: [],
				},
			],
			reasoning: "Simple test pipeline",
		});
	}
}

// Use in tests
const generator = new MockPipelineGenerator();
const result = await generator.generatePipeline({ intent: "test" });
```

---

## Performance Considerations

### Execution Time Estimates

| Node Type    | Estimated Time |
| ------------ | -------------- |
| manual_input | 0 ms           |
| http_request | 3000 ms        |
| parse        | 100 ms         |
| ai_processor | 5000 ms        |
| filter       | 50 ms          |
| transform    | 50 ms          |
| download     | 500 ms         |

**Total pipeline time** = Sum of all node times

### Optimization Tips

1. **Minimize AI nodes** - Use built-in nodes when possible (ai_processor is slow)
2. **Batch HTTP requests** - Use single request + parse instead of multiple requests
3. **Cache results** - Store intermediate results for reuse
4. **Parallel execution** - Consider parallel branches for independent operations

---

## Troubleshooting

### AI Returns Invalid JSON

**Problem:** AI response includes markdown or extra text
**Solution:** Parser automatically removes ```json wrappers

### Nodes Not Positioned Correctly

**Problem:** Overlapping nodes or off-screen
**Solution:** Check viewport width calculation, adjust spacing constants

### Missing Connections

**Problem:** Nodes exist but pipes don't connect them
**Solution:** Verify `inputs` and `outputs` arrays are correctly formatted

### Circular Dependency Error

**Problem:** Pipeline execution would loop infinitely
**Solution:** Review node connections, ensure no cycles in graph

---

## Best Practices

1. **Always validate** pipelines before execution
2. **Show loading states** during AI generation (can take 3-10 seconds)
3. **Handle errors gracefully** with user-friendly messages
4. **Estimate complexity** before execution to set user expectations
5. **Cache API key** securely (use environment variables, not hardcode)
6. **Test with mock data** before connecting to real AI API
7. **Provide examples** to users to guide their intent descriptions
